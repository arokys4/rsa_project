\documentclass[12pt,leqno]{article}  
\usepackage{graphicx} 

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm}

\title{Applied Cryptography – RSA Encryption and Secure Communication}
\author{Jakub Sikora, Mikołaj Czermak}
\date{}% - pusta data | %\date{\today} - data dzisiejsza


\begin{document}

\maketitle 

\section{Wprowadzenie}


    \subsection{Cel projektu}

    Celem projektu jest zaprojektowanie i zaimplementowanie kompletnego systemu bezpiecznej komunikacji opartego na kryptografii asymetrycznej RSA. System ma za zadanie umożliwiać generowanie kluczy kryptograficznych, szyfrowanie oraz deszyfrowanie wiadomości w celu efektywnego zabezpieczenia danych. Kluczowym elementem projektu jest stworzenie własnej implementacji algorytmów matematycznych stojących za kryptosystemem RSA, takich jak generowanie liczb pierwszych, obliczanie funkcji Eulera, wyznaczanie odwrotności modularnej oraz szybkie potęgowanie modularne. 


    \subsection{RSA (Rivest–Shamir–Adleman)}
    
        RSA to kryptosystem asymetryczny, który służy do bezpiecznego szyfrowania danych oraz tworzenia podpisów cyfrowych. Składa się z dwóch kluczy: publicznego i prywatnego.

    \begin{itemize}
        \item \textbf{Klucz publiczny} – służy do szyfrowania wiadomości oraz do weryfikowania podpisów cyfrowych. Może być udostępniany każdemu.
        \item \textbf{Klucz prywatny} – służy do odszyfrowywania wiadomości zaszyfrowanych kluczem publicznym oraz do podpisywania danych. Musi być utrzymywany w tajemnicy.
    \end{itemize}

    
    Podstawą RSA są dwie duże liczby pierwsze, których iloczyn stanowi element klucza publicznego. Bezpieczeństwo RSA wynika z trudności faktoryzacji, czyli rozkładania dużych liczb na czynniki pierwsze.
    
    RSA umożliwia:
    \begin{enumerate}
        \item bezpieczne przesyłanie danych,
        \item uwierzytelnianie dzięki podpisom cyfrowym,
        \item przekazywanie kluczy w systemach hybrydowych.
    \end{enumerate}


\section{Podstawy matematyczne}


    \subsection{Liczby pierwsze}
        Liczba pierwsza jest to dowolna liczba naturalna z dokładnie dwoma dzielnikami: jedynką (1) i nią samą.
        W algorytmie RSA wybiera się dwie duże liczby pierwsze p i q. Ich iloczyn:
        \[
        n=pq
        \]
        stanowi podstawę klucza publicznego. RSA wykorzystuje fakt, że mimo iż łatwo jest pomnożyć dwie liczby pierwsze to bardzo trudno jest je rozłożyć z powrotem na czynniki jest to tzw. problem faktoryzacji.

    
    \subsection{Funkcje jednokierunkowe}
        Funkcja jednokierunkowa – funkcja, która jest łatwa do wyliczenia, ale trudna do odwrócenia. „Łatwa do wyliczenia” oznacza tu, że istnieje algorytm wielomianowy, który ją wylicza. „Trudna do odwrócenia” oznacza, że żaden wielomianowy algorytm probabilistyczny nie potrafi znaleźć elementu przeciwobrazu \(f(x)\) z prawdopodobieństwem większym niż zaniedbywalnie, jeśli x jest wybrane losowo. Trudność dotyczy zatem średniego przypadku, a nie pesymistycznego, jak w większości problemów w teorii złożoności obliczeniowej (np. w problemach NP-trudnych)


    \subsection{Arytmetyka modularna}
        Arytmetyka modularna (arytmetyka reszt) to system liczenia reszt z dzielenia, gdzie liczby "zwijają się" po osiągnięciu określonej wartości nazywanej modułem, często nieokreślanej terminem modulo (skracane mod), działając jak zegar, np. \(17 \equiv 5 \pmod{6}\). Podstawowo operacje (dodawanie, odejmowanie, mnożenie) wykonuje się w ten sposób, ze wynik również daje resztę modułu {n}. (np. \((a+b) \bmod\ n)\). Jest kluczowa w kryptografii i informatyce a zapis \(a \equiv b \pmod{n}\) oznacza, że a i b dają tę samą resztę z dzielenia przez n (lub ich różnica jest podzielna przez n). Arytmetyka modularna jest fundamentem systemu RSA, operując na resztach z dzielenia dużych liczb: klucz publiczne \((N,e)\) i prywatny \((d)\) sa powiązanie przez operacje modulo \(N)\)
        \[
        gdzie (N = pq)\
        \]
        oraz relację        
        \[
        ed \equiv 1 \ (mod(p-1)(q-1))
        \]
        co umożliwia szyfrowanie 
        \[
        (C = M^e \pmod N)
        \]
        i deszyfrowanie
        \[
        ((M = C^d \pmod N)
        \]        
        danych, wykorzystując kongruencje i własności liczb.

    \subsection{Twierdzenie Eulera}

        Twierdzenie Eulera to ogólna nazwa dla wielu ważnych twierdzeń matematycznych, stworzonych przez Leonharda Eulera, ale najczęściej kojarzy się z dwoma kluczowymi: wzorem dla wielościanów (\(W-K+S=2\)) oraz uogólnieniem małego twierdzenia Fermata w teorii liczb (dotyczącym potęg reszt modulo \(m\)).

        
        Małe twierdzenie Fermata:
        jeśli \(p\) jest liczbą pierwsza, to dla dowolnej liczby całkowitej \(a\), liczba \(a^p-a\) jest podzielna przez \(p\).
        \[
        a^p -a \equiv 0 \pmod p
        \]   

        
        Kluczowe twierdzenie do konstrukcji klucza prywatnego:
        \[
        a^{\varphi(n)} \equiv 1 \pmod{n}, \quad \text{gdzie } \varphi(n) = (p-1)(q-1)
        \]  


    \subsection{Funkcja Eulera}

        Funkcja Eulera  \(\phi (n)\) w RSA jest kluczowa dla generowania par kluczy, zlicza liczby naturalne mniejsze od \(n\) i względnie z nią pierwsze. Oblicza się ją jako 
        \[
        \phi (n)=(p-1)(q-1)
        \] 
        ,a następnie używa się do znalezienia prywatnego wykładnika d, który jest odwrotnością publicznego wykładnika \(e\) \text{modulo} \(\phi (n)\) czyli 
        \[
        d\cdot e\equiv 1 \pmod \phi (n))
        \]
        ,co umożliwia deszyfrowanie wiadomości. Bez niej niemożliwe byłoby stworzenie pary kluczy i działanie algorytmu.
    
    
    \subsection{Odwracalność modularna (Odwrócenie modulo)}

        Odwracalność modularna (modualar inverse) w arytmetyce modulo oznacza istnienie liczby  \(x\) takiej, że dla danej liczby \(a\) i modułu \(n\), iloczyn  \(a\cdot x\) daje resztę 1 z dzielenia przez \(n\) czyli \(a\cdot x\equiv 1 \pmod n\). Odwrotność modularna istnieje wtedy i tylko wtedy, gdy największy wspólny dzielnik \(a\) i \(n\) wynosi 1 (NWD(a, n) = 1), czyli \(a\) i \(n\) są liczbami względnie pierwszymi. Odwrotność modularną najczęściej oblicza się za pomocą rozszerzonego algorytmu Euklidesa, który pozwala znależć taką liczbę że \(x\), że:
        \[
        a\cdot x+n\cdot y=1
        \]
        Ponieważ \(gcd(a,n) = 1\), równanie to ma rozwiązania, a współczynnik \(x\) jest właśnie szukaną odwrotnością modularną liczby \(a\) modulo n:
        \[
        a^{-1} \equiv x \pmod n 
        \]
        W praktyce odwrotność modularna jest niezbędna m.in. w algorytmie RSA, szczególnie podczas wyznaczania klucza prywatnego d, który spełnia równanie:
        \[
        d \equiv e^{-1}  (mod\varphi(n))
        \]
        Bez możliwości obliczenia odwrotności modularnej nie byłoby możliwe poprawne odszyfrowanie danych ani tworzenie podpisów cyfrowych. 

        
    \subsection{Potęgowanie szybkie}
    
    Szybkie potęgowanie, zwane też potęgowaniem binarnym lub przez podnoszenie do kwadratu, to algorytm do efektywnego obliczania  \(a^{b} \pmod n\), redukujący złożoność z \(O(b)\) do \(O(\log b)\) mnożeń, wykorzystując reprezentację binarną wykładnika. Zamiast liczyć \(a\cdot a\cdot a...\), algorytm kwadratowo podnosi podstawę \(a\) (tworząc \(a^{2},a^{4},a^{8},...\)) i mnoży wynik tylko przez te potęgi, których odpowiadające im bity wykładnika są jedynkami, wszystko w arytmetyce modularnej (z resztą z dzielenia).
    Szyfrowanie w RSA:
    \[
    c=m^e \pmod n
    \]
    Odszyfrowanie w RSA:
    \[
    m=c^d \pmod n
    \]
    Eksponent \(e\) może mieć 2048 bitów, a \(d\) nawet 4096 bitów. Bez potęgowania szybkiego te operacje byłby praktycznie niewykonalne.


\section{Projekt i implementacja}

    Algorytmy generowania kluczy, szyfrowania i deszyfrowania zostały zaimplementowane zgodnie z klasycznym pseudokodem RSA, którego struktura odpowiada algorytmom opisanym w literaturze kryptograficznej. Projekt został zaimplementowany w języku C++, z wykorzystaniem biblioteki \textbf{GMP (GNU Multiple Precision Arithmetic Library)} do obsługi dużych liczb całkowitych, które są niezbędne w kryptografii RSA. Architektura programu została podzielona na kilka logicznych modułów, co zwiększa czytelność kodu oraz ułatwia jego rozwój i testowanie.
    Główna cześć kryptograficzna została zawarta w klasie \texttt{RSA}, odpowiedzialnej za:
    \begin{itemize}
        \item generowanie par kluczy publiczny--prywatny
        \item szyfrowanie i deszyfrowanie pojedynczych bloków danych,
        \item szyfrowanie i deszyfrowanie ciągów znaków,
        \item testowanie pierwszości liczb metodą Millera--Rabina.
    \end{itemize}

    Generowanie kluczy polega na losowym wyborze dwóch dużych loczb pierwszych \(p)\) i \(q\), obliczaniu modułu \(n = pq\)
    
    
\section{Wyniki}

    W celu weryfikacji poprawności implementacji przeprowadzono serię testów funkcjonalnych. Sprawdzono poprawność generowania kluczy, a także poprawność procesu szyfrowania i deszyfrowania wiadomości.
    
    Testy wykazały, że dla poprawnie wygenerowanej pary kluczy, odszyfrowanie wiadomości zaszyfrowanej kluczem publicznym zawsze zwraca oryginalny tekst wejściowy. Testy przeprowadzono dla różnych długości wiadomości, zawierających znaki alfanumeryczne oraz znaki specjalne.

    Dodatkowo sprawdzono poprawność działania algorytmów matematycznych, takich jak:
    \begin{itemize}
        \item rozszerzony algorytm Eukldesa,
        \item obliczanie odwrotności modularnej,
        \item szybkie potęgowanie modularne.
    \end{itemize}

    Dla celów demonstracyjnych używano kluczy o mniejszej długości bitowej (np. 128 lub 256 bitów), co pozwoliło na szybkie generowanie kluczy i sprawną demonstrację działania systemu. Dla większych długości kluczy zauważalny był wzrost czasu generowania, co jest zgodne z oczekiwaniami teoretycznymi. 

    Przykładowy test:
    \begin{itemize}
        \item Wiadomość jawna: \texttt{HELLO}
        \item Zaszyfrowany blok: \texttt{[123456789012345]}
        \item Odszyfrowana wiadomość: \texttt{HELLO}
    \end{itemize}


\section{Analiza bezpieczeństwa}

    Bezpieczeństwo kryptosystemu RSA opiera się na trudności faktoryzacji dużych liczb będących iloczynem dwóch liczb pierwszych. Przy odpowiednio dużych rozmiarach kluczy (np. 2048 bitów i więcej) obecnie nie istnieją znane algorytmy, które umożliwiałyby złamanie RSA w rozsądnym czasie.
    
    Należy jednak podkreślić, że zaprezentowana implementacja ma charakter edukacyjny. Zastosowane kodowanie wiadomości jest uproszczone i nie wykorzystuje standardowych schematów wypełniania (paddingu), takich jak OAEP. Brak paddingu może w rzeczywistych systemach prowadzić do podatności na ataki kryptograficzne.
    
    Ponadto generator liczb losowych użyty w projekcie nie jest kryptograficznie bezpieczny, co również ogranicza zastosowanie systemu w realnych warunkach. W praktycznych implementacjach RSA stosuje się specjalizowane źródła losowości oraz dodatkowe zabezpieczenia.
    
    Mimo tych ograniczeń, projekt poprawnie demonstruje zasadę działania kryptografii asymetrycznej i spełnia założenia funkcjonalne algorytmu RSA.


\section{Wnioski}

    W ramach projektu udało się zaprojektować i zaimplementować kompletny system kryptograficzny oparty na algorytmie RSA. Projekt pozwolił na praktyczne zastosowanie wiedzy z zakresu teorii liczb, arytmetyki modularnej oraz algorytmów kryptograficznych.
    
    Implementacja umożliwia generowanie kluczy, szyfrowanie oraz deszyfrowanie wiadomości, a także prezentuje pełny proces bezpiecznej komunikacji w modelu kryptografii asymetrycznej. Praca nad projektem pozwoliła lepiej zrozumieć zarówno matematyczne podstawy RSA, jak i praktyczne aspekty implementacji kryptografii.
    
    W przyszłości projekt mógłby zostać rozszerzony o zastosowanie standardowych schematów paddingu, integrację szyfrowania symetrycznego (np. AES) oraz użycie kryptograficznie bezpiecznych generatorów liczb losowych, co pozwoliłoby zbliżyć implementację do standardów stosowanych w rzeczywistych systemach bezpieczeństwa.

    
\section{Instrukcja użytkownika}

    Szczegółowa instrukcja obsługi programu, wraz z przykładami użycia interfejsu wiersza poleceń, została zamieszczona w pliku \texttt{README.md} w repozytorium projektu.


\end{document}

 
